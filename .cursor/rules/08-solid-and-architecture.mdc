---
description: Architecture invariants (SOLID) and change isolation
globs:
alwaysApply: true
---

# Architecture Invariants

## SOLID Principles

- **SRP**: Each module/class has one reason to change.
- **OCP**: Prefer extension points over editing stable internals.
- **LSP**: Respect substitution contracts (subtypes must be substitutable for base types).
- **ISP**: Segregate interfaces (clients shouldn't depend on unused methods).
- **DIP**: Depend on abstractions, not concretions.

## Universal Complexity Standards

### Function-Level Metrics
- **Cyclomatic Complexity**: Maximum 10 per function
- **Cognitive Complexity**: Maximum 15 per function
- **Lines per Function**: Maximum 50 lines
- **Parameters per Function**: Maximum 5 parameters

### Class/Module-Level Metrics
- **Methods per Class**: Maximum 10 methods
- **Fields per Class**: Maximum 15 fields
- **Lines per File**: Maximum 1000 lines
- **Nesting Depth**: Maximum 4 levels

### Critical Function Standards
For auth, billing, data processing:
- **Cyclomatic Complexity**: Maximum 5
- **Cognitive Complexity**: Maximum 10
- **Mandatory**: Error handling, input validation, audit logging

## Change Isolation

- Introduce seams (interfaces/strategies) near integration points.
- Add tests at seams; assert unchanged public behavior.
- Use dependency injection for testable architecture.
- Implement circuit breakers for external dependencies.

## Enforcement Mechanisms

### Automated Detection
```bash
# Check complexity metrics
npm run complexity:check
# - Cyclomatic complexity analysis
# - Cognitive complexity analysis
# - File size violations
# - Nesting depth violations

# Check architectural violations
npm run architecture:check
# - SOLID principle violations
# - Dependency cycle detection
# - Interface segregation violations
```

### Pre-Commit Hooks
```bash
# Block commits with high complexity
if complexity_score > threshold; then
  echo "‚ùå Complexity exceeds threshold"
  echo "Refactor to reduce complexity"
  exit 1
fi
```

## Universal Patterns

### Dependency Injection (All Languages)
```typescript
// TypeScript
class OrderService {
  constructor(
    private userRepo: UserRepository,
    private paymentService: PaymentService
  ) {}
}
```

```rust
// Rust
struct OrderService {
    user_repo: Box<dyn UserRepository>,
    payment_service: Box<dyn PaymentService>,
}
```

```python
# Python
class OrderService:
    def __init__(self, user_repo: UserRepository, payment_service: PaymentService):
        self.user_repo = user_repo
        self.payment_service = payment_service
```

### Error Handling (All Languages)
```typescript
// TypeScript - Result pattern
type Result<T, E> = { success: true; data: T } | { success: false; error: E };
```

```rust
// Rust - Result type
fn process_order(order: Order) -> Result<OrderResult, OrderError>
```

```python
# Python - Custom exceptions
class OrderError(Exception):
    def __init__(self, message: str, context: dict = None):
        super().__init__(message)
        self.context = context or {}
```

## Quality Metrics

### Architecture Quality Score
```
Architecture Score = (
  SOLID Compliance * 0.3 +
  Complexity Score * 0.3 +
  Testability Score * 0.2 +
  Maintainability Score * 0.2
) * 100
```

### Continuous Monitoring
- Track complexity trends over time
- Monitor architectural debt accumulation
- Alert on SOLID principle violations
- Report maintainability metrics
